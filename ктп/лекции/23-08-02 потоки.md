задача емае
рассмотрим квадратное поле, разбитое на клеточки. некоторые клетки запрещены. есть доминошки 2х1, которыми нужно покрыть поле. возможно ли это?

раскрасим поле в шахматном порядке, разделим поле на двудольный граф, где все белые в одной доле, черные в другой. соединим белую и черную, если на них лежит доминошка.

---
## алгоритм Куна
### теорема Бержа
пусть на текущий момент есть двудольный граф. выбраны какие-то паросочетания.

будет классно, если мы можем найти чередующуюся цепь (из невыбранных и выбранных ребер). в таком случае мы можем инвертировать выбор, и выбранных станет больше.
```
-о-о-
о-о-о
```

пусть есть двудольный граф. пока еще ниче не выбрали. ```mt[]``` - массив значений (-1 по умолчанию) того, принадлежит ли вершина из правой доли выбранному ребру. вместо -1 ставим номер вершины левой доли, из которой мы пришли в dfs. 

запускаем dfs в первой вершинке, заканчиваем его, когда приходим в вершину с -1, заменяем -1 на номер вершины, из которой пришли, и инвертируем невыбранные на выбранные. по алгоритму мы всегда идем по невыбранному и возвращаемся по выбранному, пока не придем в тупик.

```cpp
int dfs(int v)
{
	was[v] = 1 // мы тут были
	for (auto to: g[i])
	{
		if (was[to] == 0 && mt[to] == -1 || dfs(mt[to]) == 1)
		{
			mt[to] = i;
			return 1;
		}
	}
	return 0;
}
```

эта фигнюшка запускается в ```for (i=...n)```.

количество элементов ```mt[.]``` не равных -1 равно количеству ребер в паросочетании.


---

та же задача, доминошки есть 2x1 и 1x1, но они платные. доминошка 2x1 стоит A денег, 1х1 стоит B денег. нужно замостить поле как можно дешевле.

1. если 2B \le A, то вообще пофиг.
2. иначе находим макс парсоч для больших доминошек и остальное мостим маленькими доминошками.

## потоки собсна
пусть дан граф $G=<V, E>$

поток в графе - функция $F(e)$, где $e \in E$, которая удовлеворяет следующим пунктам:

1. $F(e) \le \text{cap[e]}$ (где cap[e] - пропускная способность)
2. $F(e) = F(u \to v) = -F(v \to u) = -F(\hat e)$ 
3. $\underset{u}{\sum} F(v,\ u) = 0$ (т. е. сумма входящих потоков равна сумме исходящих потоков.)

---

### Форд-Фалкерсон
* для этой фигни приходится хранить граф не в виде смежности, а в виде инцидентности.
```cpp
vector <int> g[10000]
int f[1000]
int cap[1000]
int to[10000]

int dfs(s) (int v, int flow = INF)
{
	was[v] = 1;
	for (auto to: g[v])
	{
		int to = ::to[e];
		int tmp = min(flow, cap[e] - f[e]);
		if (was[to]) continue
		tmp = dfs(to, tmp);
		if (tmp > 0)
		{
			f[e] += tmp;
			f[e^1] -= temp;
			// мы храним обратные ребра последовательными индексами, поэтому два соседних индекса противоположны друг другу. отличаются они одним знаком. финт ушами.
			return tmp;
		}
	}
}

main
{
	int flow = 0;
	while ((int f = dfs(s)) > 0)
		flow += f;
		fill was // я слишком не знаю плюсов,
		//но тут надо чистить нулями... что-то....
}
```