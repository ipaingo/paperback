# кратчайшие пути
## взвешенные графы
### Дейкстра
- $O((n+m) \cdot \log n)\ \longrightarrow\ n^2 \cdot \log$
- $O(n \cdot n + m)$

### алгоритм Флойда
ищет кратчайшее расстояние из i в j.
почему не Дейкстра?
Дейкстра имеет сложность $(n + m) \log$ и выполняется для каждой вершины, то есть всего времени $n^2 \cdot \log +\ n \cdot m \cdot \log.$ ну не очень, короче. алгоритм Флойда позволяет избавиться от логарифма и других штук.

```cpp
for k = 1..n
	for i = 1..n
		for j = 1..n
			a[i][j] = min(a[i][j], a[i][k] + a[k][j])
			// изначально a - матрица смежности.
```

если нам также нужен сам путь, все изменения маршрута мы будем записывать в массив, и потом его выведем.

сложность - $m^3$

---

алгоритмы Флойда и Дейкстры работают только для графов, где есть конечный путь из одной вершины в другую. например, в графе с отрицательным циклом кратчайший путь будет $-\infty$

### алгоритм Форда-Беллмана

табличка - за сколько можно попасть из 1 вершины в n-ую?

| путь   | вес |
| ------ | --- |
| 1 -> 2 | 1   |
| 3 -> 4 | -4  |
| 3 -> 5 | 4   |
| 2 -> 3 | 2   |
| 4 -> 2 | 1   |

| 1   | 2        | 3        | 4            | 5        |
| --- | -------- | -------- | ------------ | -------- |
| 0   | $\infty$ | $\infty$ | $\infty$     | $\infty$ |
|     | 1        | 3        | $\infty - 4$ |          |
|     |          |          | -1           | 7        |
|     | 0        | 2        | -2           | 6        | 

```cpp
s; // начальная вершина
e; // веса
dist[s] = 0;
dist[i != s] = infty;
for t = 1..n
{
	for i // i - индекс ребра
	{
		u = g[i].first();
		v = g[i].second();
		
		if (dist[v] > dist[u] + e[i])
		{
			обновляем
		}
	}
}
```

## 0 1 bfs
предположим, что взвешенный граф имеет ребра с длинами 0 и 1.

для такого случая можно использовать Дейкстру, но можно поступить и эффективнее.

дописания

# про деревья

граф без циклов, совсем.

в чем плюс: путь из одной вершины в другую всегда один. при этом двигаться всегда нужно сначала вверх, до минимального общего предка (LCA), потом вниз.

тогда путь равен путь от ```a``` до ```c = LCA(a, b)``` + путь от ```c``` до ```b```.

находим ```LCA(a, b)```, затем ```p(root, a) + p(root, b) - 2*p(root,c)``` и сё.

#### 1
```cpp
if(tin[a] <= tin[b]) && (tout[b] <= tout[a])
	true
```
#### 2
$$\forall\ c \in \mathbb{N}\ \exists\ x_i \in \mathbb{N} \cup {0} : c = \sum 2^{x^i}$$

#### 3
$$lca(a, b) = \left[\begin{array}{l}a,\quad \text{if ispar(a,b)} \\ b,\quad \text{if ispar(b, a)} \\ lca(p[a], b) = lca(a, p[b])\end{array}\right.$$

```cpp
while(!ispar(a, b))
	a = p[a];
```

я всё.
