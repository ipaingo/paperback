## определения чето
граф: $$F = <V,\ E>$$

графы:
1. ориентированные
2. неориентированные
---
1. циклические
2. ациклические
---
1. взешенные
2. невзвешенные

ациклический неоринтированный - дерево
ациклический ориентированный - сеть

как хранить:
1. матрица смежности

|     | 1   | 2   | 3   |
| --- | --- | --- | --- |
| 1   | 0   | 1   | 1   |
| 2   | 1   | 0   | 0   |
| 3   | 1   | 0   | 0   |
```cpp
int g[100][100]

g[i][j] = 1; // если ребро есть
g[i][j] = 0; // если ребра нет
```
2. список смежности
```cpp
vector<int> g[100];
g[i] = {...};
// пример:
g[1] = {2, 3};
// как перебрать все смежные:
for (int i = 0; i<g[v].size(); i++)
	int to = g[v][i];

// либо
for(auto to: g[v])
	...

```
3. матрица инцидентности

|     | a   | b   |
| --- | --- | --- |
| 1   | 1   | 1   |
| 2   | 1   | 0   |
| 3   | 0   | 1   |

4. список инцидентности
	1. {a, b}
	2. {a}
	3. {b}

|     | a   | a'  | b   | b'  |
| --- | --- | --- | --- | --- |
| 1   | -1  | 1   | 1   | -1  |
| 2   | 1   | -1  |     |     |
| 3   | 0   |     | -1  | 1   | 

5. список ребер
*список пар вершинок, образующих ребра.*

## обход в глубину - dfs
*ваще не связан с кратчайшими путями, если што.*
dfs = depth first search.
если аналогии проводить - тыкаем по вложенным страницам на сайтике.

![[Pasted image 20230321173618.png]]

4 -> 8 -> 7 -> 5 -> нет новых вершин, возвращаемся обратно -> 4 -> 2 -> 3 -> 1 -> 6 -> обратно -> 4

---

1. достижимость
2. выделение дерева сети
3. циклы

*если мы обходим ориентированный граф, цикл есть, если при обходе мы приходим в вершинку, в которой уже были, но еще не возвращались из нее.*
```cpp
vector<int> g[1000]; // по коням, у нас граф. возможно, ориентированный.
int was[1000];
int fl = 0; // флажок цикла.

void dfs(int v, int p)
{
	was[v] = 1;
	for(auto to: g[v])
	{
		if(to == p)
			continue;
		if(was[to]==0)
			dfs(to, v);
		else
			fl = 1;
	}
	was[v] = 2;
}
// особенность - пашет только для связных графов/подграфов.
```
как узнать, что из a можно попасть в b:
	1. dfs
	2. if(was[b]) то достижима

узнаем, есть ли цикл, для ориент. графа:

```cpp
vector<int> g[1000]; // по коням, у нас граф. возможно, ориентированный.
int was[1000];
int fl = 0; // флажок цикла.

void dfs(int v, int p)
{
	was[v] = 1;
	for(auto to: g[v])
	{
		if(was[to]==2)
			fl = 1;
		if(was[to]==0)
			dfs(to, v);
	}
	was[v] = 2;
}
// особенность - пашет только для связных графов/подграфов.
```


еще какое-то изменение, но я перестала обрабатывать происходящее:

```cpp
vector<int> g[1000];
int was[1000];
int fl = 0; // флажок цикла.

void dfs(int v, int p = -1)
{
	par[v] = p; // предыдущая вершина, предок(?)
	was[v] = 1;
	for(auto to: g[v])
	{
		if(was[to]==2)
		{
			fl = 1;
			st = to;
		}
		if(was[to]==0)
			dfs(to, v);
	}
	was[v] = 2;
}
```

че?

```cpp
vector<int> path;
path.push_back(f);

while((f = par[f]) != st)
	path.push_back(f);

path.push_back(f);

// теперь path - путь от финиша к старту.

reverse(path.begin(), path.end())
// теперь все правильно.
```


4. связность
5. проверка графа на эйлеровость

```cpp
comp = 0; // кол-во компонент связаности.
for (int i = 1...n)
{
	if(was[i] == 0)
	{
		dfs(i);
		comp++;
	}
}
```

эйлеров путь - путь, который проходит все ребра по одному разу.

```cpp
set<int> g[1000]; // так быстрее.
int was[1000];
int fl = 0;

void dfs(int v, int p = -1)
{
	par[v] = p;
	was[v] = 1;
	
	while(g[v].size()>0)
	{
		to = g[v].begin();
		g[v].erase(to);
		// если граф не ориентированный, то g[t].erase(v)
		dfs(to)
	}
	path.push_back(v);
}
```

6. проверка на количество сильной связности
7. центроид...
8. сортировка....
9. и тд и тд