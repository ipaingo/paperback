Напишите программу формирования цифровой подписи алгоритмом RSA. Рекомендуется использовать библиотеку для работы с длинными числами. В случае применения этой библиотеки разрешается использовать функции сложения, вычитания, умножения, целочисленного деления, вычисления остатка от деления. Функции возведения числа в степень, нахождения наибольшего общего делителя, обратного элемента в мультипликативной группе вычетов, генерации простого числа реализовать самостоятельно. Для ускорения вычислений использовать китайскую теорему об остатках. Выполняемые функции программы:
1) генерация пары открытый/закрытый ключ, при этом число e задается пользователем;
2) получения цифровой подписи для сообщения (целого числа);
3) проверки цифровой подписи для данного сообщения (целого числа).

## метод решения

Задача решается написанием алгоритма RSA на языке C#. Для генерации псевдопростых чисел используется тест Миллера-Рабина. Для нахождения наибольшего общего делителя используется расширенный алгоритм Евклида. В соответствии с заданием в решении используется китайская теорема об остатках.

RSA-ключи генерируются следующим образом:

1) выбираются два различных случайных простых числа p и q заданного размера;
2) вычисляется их произведение n = p * q, которое называется модулем;
3) вычисляется значение функции Эйлера от числа n: ф(n) = (p-1) * (q-1);
4) выбирается целое число e (1 < e < ф(n)), которое называется открытой экспонентой (англ. public exponent).
   Обычно в качестве e берут простые числа, содержащие небольшое количество единичных бит в двоичной записи, например, простые из чисел Ферма: 17, 257 или 65537, так как в этом случае время, необходимое для шифрования с использованием быстрого возведения в степень, будет меньше. Слишком малые значения, например 3, потенциально могут ослабить безопасность схемы RSA.
6) вычисляется число d, мультипликативно обратное к числу e по модулю ф(n), то есть число, удовлетворяющее сравнению: $d\cdot e\equiv 1{\pmod {\varphi (n)}}$
(число d называется секретной экспонентой; обычно оно вычисляется при помощи расширенного алгоритма Евклида);
6) пара (e, n) публикуется в качестве открытого ключа RSA (англ. RSA public key);
7) пара (d, n) играет роль закрытого ключа RSA (англ. RSA private key) и держится в секрете.

---

RSA можно использовать для шифрования и расшифрования сообщений, а также для создания цифровой подписи.

### шифрование
шифрование происходит с помощью открытого ключа:
1. берется открытый ключ (e, n)
2. берется открытый текст m
3. $c=E(m)=m^{e}\mod n$

для расшифрования используется закрытый ключ:
1. берется закрытый ключ (d, n)
2. берется зашифрованный текст c
3. $m=D(c)=c^{d}\mod n$

### цифровая подпись
создание цифровой подписи происходит следующим образом:

1. берется открытый текст m
2. берется закрытый ключ (d, n)
3. $s=S_{A}\left(m\right)=m^{d}\mod n$

проверка цифровой подписи происходит следующим образом:
1. берется пара из сообщения и цифровой подписи (m, s)
2. берется открытый ключ (e, n)
3. $m'=P_{A}\left(s\right)=s^{e}\mod n$
4. проверить: $m = m'$. если равенство верно, то подпись действительна, а сообщение не изменено.

## код решения


```cs
using System.Numerics;
using System;
using System.Security.Cryptography;
using System.Runtime.CompilerServices;

// возведение в степень. рекурсия.
BigInteger BinPow(BigInteger n, BigInteger k, BigInteger mod)
{
    if (k == 0)
        return new BigInteger(1);
    if (k == 1)
        return n % mod;

    // деление с остатком.
    var mid = BinPow(n, k / 2, mod);
    return mid * mid * (k % 2 == 1 ? n : 1) % mod;
}

// функция поиска простых чисел с помощью решета Эратосфена.
// используется для предподсчета массива небольших простых чисел.
List<int> generateLowPrimes()
{
    bool[] sieve = new bool[2000];
    for (int i = 2; i < 2000; i++)
        if (!sieve[i])
            for (int j = i * i; j < 2000; j += i)
                sieve[j] = true;

    var primes = new List<int>();
    for (int i = 2; i < 2000; i++)
        if (!sieve[i])
            primes.Add(i);

    return primes;
}

var lowPrimes = generateLowPrimes();

// определяет, является ли число простым. тест Миллера-Рабина.
bool isMaybePrime(BigInteger prime)
{
    for (int i = 0; i < lowPrimes.Count; i++)
    {
        int lp = lowPrimes[i];
        if (lp == prime)
            return true;
        if (prime % lp == 0)
            return false;
    }

    int s = 0;
    BigInteger t = prime - 1;
    while (t % 2 == 0)
    {
        t /= 2;
        s++;
    }

    int iters = 256;
    while (iters-- > 0)
    {
        var a = RandBigIntegerInRange(2, prime - 2);
        var x = BinPow(a, t, prime);
        if (x == 1 || x == prime - 1)
            continue;

        bool flag = true;
        for (int i = 1; i < s; i++)
        {
            x = BinPow(x, 2, prime);
            if (x == 1)
                return false;
            if (x == prime - 1)
            {
                flag = false;
                break;
            }
        }
        if (flag)
            return false;
    }

    return true;
}

// генерирует БОЛЬШОЕ случайное число в заданном отрезке.
BigInteger RandBigIntegerInRange(BigInteger minValue, BigInteger maxValue)
{
    if (minValue == maxValue) return minValue;

    var random = new Random();
    BigInteger zeroBasedUpperBound = maxValue - 1 - minValue;
    byte[] bytes = zeroBasedUpperBound.ToByteArray();

    byte lastByteMask = 0b11111111;
    for (byte mask = 0b10000000; mask > 0; mask >>= 1, lastByteMask >>= 1)
        if ((bytes[bytes.Length - 1] & mask) == mask) break;

    while (true)
    {
        random.NextBytes(bytes);
        bytes[bytes.Length - 1] &= lastByteMask;
        var result = new BigInteger(bytes);
        if (result <= zeroBasedUpperBound) return result + minValue;
    }
}

// функция генерации случайного простого числа.
BigInteger getRandomPrime()
{
    while (true)
    {
        // по сути генерирует псевдослучайное число и проверяет,
        // не получилось ли оно составным.
        int bits = 256;
        BigInteger min = 1, max = 2;
        while (--bits > 0)
        {
            min *= 2;
            max *= 2;
        }

        min++;
        max--;
        var prime = RandBigIntegerInRange(min, max);
        if (prime % 2 == 0)
            prime += 1;
        if (!isMaybePrime(prime))
            continue;
        return prime;
    }
}

// функция нахождения наибольшего общего делителя.
// используется в китайской теореме об остатках.
BigInteger GCD(BigInteger a, BigInteger b)
{
    if (b > a)
        (a, b) = (b, a);
    while (b > 0)
    {
        a %= b;
        (a, b) = (b, a);
    }

    return a;
}

// функция вычисления закрытого ключа. расширенный алгоритм Евклида.
BigInteger GCDex(BigInteger a, BigInteger b, out BigInteger x, out BigInteger y)
{
    if (a == 0)
    {
        x = 0; y = 1;
        return b;
    }
    BigInteger x1, y1;
    BigInteger d = GCDex(b % a, a, out x1, out y1);
    x = y1 - (b / a) * x1;
    y = x1;
    return d;
}

// функция генерации RSA ключей.
void generateRSAKeys(BigInteger e, out BigInteger d, out BigInteger n, out BigInteger p, out BigInteger q)
{
    BigInteger f;
    do
    {
        // генерирует случайные простые p и q.
        p = getRandomPrime();
        q = getRandomPrime();
        n = p * q;              // модуль.
        f = (p - 1) * (q - 1);  // функция Эйлера.
    }
    while (GCD(e, f) != 1);

    // секретная экспонента d генерируется с помощью расширенного алгоритма Евклида.
    GCDex(e, f, out d, out BigInteger y);
    d = (d % f + f) % f;
}


// получает цифровую подпись.
BigInteger getCert(in BigInteger m, in BigInteger d, in BigInteger n, in BigInteger p, in BigInteger q)
{
    // для быстрого вычисления используется китайская теорема об остатках.
    // вместо того, чтобы возводить сообщение m в степень d,
    // мы используем тот факт, что p и q взаимнопростые,
    // а значит мы можем возвести в меньшую степень по модулю (что будет проще),
    // после чего китайскими ухищрениями вычислим остаток от деления на n меньшего числа.
    var r1 = BinPow(m % p, d % (p - 1), p);
    var r2 = BinPow(m % q, d % (q - 1), q);

    BigInteger m1, m2;
    GCDex(q, p, out m1, out BigInteger y1);
    GCDex(p, q, out m2, out BigInteger y2);
    m1 = (m1 % p + p) % p;
    m2 = (m2 % q + q) % q;

    return (r1 * m1 * q + r2 * m2 * p) % n;
}

// проверка цифровой подписи.
bool validateCert(in BigInteger m, in BigInteger cert, in BigInteger e, BigInteger n)
{
    return m == BinPow(cert, e, n);
}


BigInteger m = 1111;    // сообщение.
BigInteger e = 65537;   // по условию открытая экспонента задается пользователем.
BigInteger n, d, p, q;
generateRSAKeys(e, out d, out n, out p, out q);

Console.WriteLine($"Открытый ключ (e, n): ({e}, {n})");
Console.WriteLine($"Закрытый ключ (d, n): ({d}, {n})");

var cert = getCert(m, d, n, p, q);

Console.WriteLine("Цифровая подпись:");
Console.WriteLine(cert);

if (validateCert(m, cert, e, n))
    Console.WriteLine("Цифровая подпись действительна.");
else
    Console.WriteLine("Цифровая подпись недействительна.");

if (validateCert(m, cert + 4, e, n))
    Console.WriteLine("Измененная цифровая подпись действительна.");
else
    Console.WriteLine("Измененная цифровая подпись недействительна.");
```


## пример вывода

```
Открытый ключ (e, n): (65537, 7202313713150694715169380563198364799077992330698500962639547109550148440367943641809073008555498553605481265240438137599716748204587500909154900733830159)
Закрытый ключ (d, n): (1066989087705877519410096829090329490734214680848249780219835556809472377550553834456525815810131732250402934520426698342545962557673108971782321252546601, 7202313713150694715169380563198364799077992330698500962639547109550148440367943641809073008555498553605481265240438137599716748204587500909154900733830159)
Цифровая подпись:
6273174975690133778755597356256215538471665904657659776496250247117983704565970694621898727530940735852818086577084213502209026525912683217253890521079604
Цифровая подпись действительна.
Измененная цифровая подпись недействительна.
```