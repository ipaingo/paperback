Реализуйте криптосистему Эль-Гамаля. Рекомендуется использовать библиотеку для работы с длинными числами. В случае применения этой библиотеки разрешается использовать функции сложения, вычитания, умножения, целочисленного деления, вычисления остатка от деления. Функции возведения числа в степень, нахождения наибольшего общего делителя, обратного элемента в мультипликативной группе вычетов, генерации простого числа реализовать самостоятельно. Выполняемые функции программы:
1) генерация чисел p, g, x, k;
2) получения цифровой подписи для сообщения (целого числа);
3) проверки цифровой подписи для данного сообщения (целого числа).

## метод решения
Задача решается написанием схемы Эль-Гамаля на языке C#. Для генерации псевдопростых чисел используется тест Миллера-Рабина.

Для нахождения первообразного корня используется факторизация числа Эйлера от простого числа:
	Находим $\phi(n)$, факторизуем его. Теперь перебираем все числа $g = 1 \ldots n$, и для каждого считаем все величины $g^{ \frac{ \phi(n) }{ p_i } } \pmod{n}$. Если для текущего $g$ все эти числа оказались отличными от $1$, то это $g$ и является искомым первообразным корнем.
	http://e-maxx.ru/algo/export_primitive_root

Алгоритм шифрования похож на RSA, но основан на трудности вычисления дискретного логарифма.

### генерация ключей
1. Генерируется случайное простое число $p$.
2. Выбирается целое число $g$ — первообразный корень по модулю $p$.
3. Выбирается случайное целое число $x$ такое, что $(1 < x < p - 1)$.
4. Вычисляется $y = g^x \mod p$.
5. Открытым ключом является $(y,\ g,\ p)$, закрытым ключом — число $x$.

### шифрование
0. Сообщение $M$ должно быть меньше числа $p$.
1. Выбирается случайное целое число $k$, $1 < k < p-1$.
2. Вычисляются $a = g^k \mod p$ и $b = y^k M \mod p$.
3. Пара чисел $(a,\ b)$ передается получателю сообщения.

#### расшифрование
Для расшифровки необходимо знать закрытый ключ $x$.
$$M = b{(a^x)}^{-1} \mod p$$
Для практических вычислений используется формула:
$$M = b{(a^x)}^{-1} = ba^{(p-1-x)} (\mod p)$$

### генерация цифровой подписи
1. Вычисляется хеш функция сообщения $M$: $m = h(M)$ (хеш-функция $h$ может быть любой).
2. Выбирается случайное число $1 < k < p-1$, взаимно простое с $p-1$, вычисляется $r = g^k \mod p$.
3. вычисляется число $s = (m - xr) k^{-1} (\mod (p-1))$, где $k^{-1}$ — мультипликативное обратное $k$ по модулю $p-1$ (находится с помощью расширенного алгоритма Евклида).
4. подписью сообщения $M$ является пара $(r,\ s)$.

#### проверка цифровой подписи
Для проверки необходим открытый ключ $(p,\ g,\ y)$, сообщение $M$ и его подпись $(r,\ s)$.
1. Проверяется, что $0 < r < p$ и $0 < s < p-1$. Если одно из условий не выполняется, подпись считается недействительной.
2. Вычисляется хеш сообщения: $m = h(M)$.
3. Проверяется, что $y^r r^s \equiv g^m \mod p$. Если это тождество выполняется, то подпись считается действительной.

## код решения
```C#
using System;
using System.Numerics;
using System.Collections.Generic;


// возведение в степень. рекурсия.
BigInteger BinPow(BigInteger n, BigInteger k, BigInteger mod)
{
    if (k == 0)
        return new BigInteger(1);
    if (k == 1)
        return n % mod;

    // деление с остатком.
    var mid = BinPow(n, k / 2, mod);
    return mid * mid * (k % 2 == 1 ? n : 1) % mod;
}

// функция поиска простых чисел с помощью решета Эратосфена.
// используется для предподсчета массива небольших простых чисел.
List<int> generateLowPrimes()
{
    bool[] sieve = new bool[2000];
    for (int i = 2; i < 2000; i++)
        if (!sieve[i])
            for (int j = i * i; j < 2000; j += i)
                sieve[j] = true;

    var primes = new List<int>();
    for (int i = 2; i < 2000; i++)
        if (!sieve[i])
            primes.Add(i);

    return primes;
}

var lowPrimes = generateLowPrimes();

// определяет, является ли число простым. тест Миллера-Рабина.
bool isMaybePrime(BigInteger prime)
{
    for (int i = 0; i < lowPrimes.Count; i++)
    {
        if (lowPrimes[i] == prime)
            return true;
        if (prime % lowPrimes[i] == 0)
            return false;
    }

    int s = 0;
    BigInteger t = prime - 1;
    while (t % 2 == 0)
    {
        t /= 2;
        s++;
    }

    int iters = 256;
    while (iters-- > 0)
    {
        var a = RandBigIntegerInRange(2, prime - 2);
        var x = BinPow(a, t, prime);
        if (x == 1 || x == prime - 1)
            continue;

        bool flag = true;
        for (int i = 1; i < s; i++)
        {
            x = BinPow(x, 2, prime);
            if (x == 1)
                return false;
            if (x == prime - 1)
            {
                flag = false;
                break;
            }
        }
        if (flag)
            return false;
    }

    return true;
}

// генерирует БОЛЬШОЕ случайное число в заданном отрезке.
BigInteger RandBigIntegerInRange(BigInteger minValue, BigInteger maxValue)
{
    if (minValue == maxValue) return minValue;

    var random = new Random();
    BigInteger zeroBasedUpperBound = maxValue - 1 - minValue;
    byte[] bytes = zeroBasedUpperBound.ToByteArray();

    byte lastByteMask = 0b11111111;
    for (byte mask = 0b10000000; mask > 0; mask >>= 1, lastByteMask >>= 1)
        if ((bytes[bytes.Length - 1] & mask) == mask) break;

    while (true)
    {
        random.NextBytes(bytes);
        bytes[bytes.Length - 1] &= lastByteMask;
        var result = new BigInteger(bytes);
        if (result <= zeroBasedUpperBound) return result + minValue;
    }
}

// функция генерации случайного простого числа.
BigInteger getRandomPrime()
{
    while (true)
    {
        // по сути генерирует псевдослучайное число и проверяет,
        // не получилось ли оно составным.
        int bits = 32;
        BigInteger min = 1, max = 2;
        while (--bits > 0)
        {
            min *= 2;
            max *= 2;
        }

        min++;
        max--;
        var prime = RandBigIntegerInRange(min, max);
        if (prime % 2 == 0)
            prime += 1;
        if (!isMaybePrime(prime))
            continue;
        return prime;
    }
}

// функция нахождения наибольшего общего делителя.
BigInteger GCD(BigInteger a, BigInteger b)
{
    if (b > a)
        (a, b) = (b, a);
    while (b > 0)
    {
        a %= b;
        (a, b) = (b, a);
    }

    return a;
}

// расширенный алгоритм Евклида. используется для нахождения обратного по модулю яисла.
BigInteger GCDex(BigInteger a, BigInteger b, out BigInteger x, out BigInteger y)
{
    if (a == 0)
    {
        x = 0; y = 1;
        return b;
    }
    BigInteger x1, y1;
    BigInteger d = GCDex(b % a, a, out x1, out y1);
    x = y1 - (b / a) * x1;
    y = x1;
    return d;
}

// функция поиска первообразного корня.
BigInteger GeneratePrimitiveRoot(BigInteger p)
{
    var f = new List<BigInteger>();
    var n = p - 1;
    for (var i = 2; i*i <= n; i++)
    {
        if (n % i == 0)
        {
            f.Add(i);
            while (n % i == 0)
                n = n / i;
        }
    }
    if (n != 1)
        f.Add(n);

    n = p - 1;
    for (var i = 2; i < p; i++)
    {
        bool flag = true;
        foreach (var k in f)
            flag = flag && (BinPow(i, n / k, p) != 1);

        if (flag)
            return i;
    }

    return 0;
}

// функция генерации ключей для схемы Эль-Гамаля.
void GenerateElgamalKeys(out BigInteger y, out BigInteger g, out BigInteger p, out BigInteger x)
{
    p = getRandomPrime();
    g = GeneratePrimitiveRoot(p);
    x = RandBigIntegerInRange(2, p - 2);
    y = BinPow(g, x, p);
}

// функция генерации цифровой подписи.
void GenerateCert(in BigInteger p, in BigInteger g, in BigInteger x, in BigInteger m, out BigInteger r, out BigInteger s)
{
    BigInteger k, k_inv;

    do
        k = RandBigIntegerInRange(2, p - 2); // случайное число k от 1 до n-1.
    while (GCD(k, p - 1) != 1); // k и n-1 должны быть взаимопростыми.

    r = BinPow(g, k, p); // r = g^k mod n.
    GCDex(k, p - 1, out k_inv, out BigInteger y); // k^-1 mod (n-1).

    k_inv = (k_inv % (p - 1) + (p - 1)) % (p - 1); // нужно, чтобы k_inv было в пределах от 0 до p-1.

    s = (m - x * r) * k_inv % (p - 1);
    s = (s % (p - 1) + (p - 1)) % (p - 1); // аналогично с k_inv.
}

// проверка цифровой подписи.
bool ValidateCert(BigInteger p, BigInteger g, BigInteger y, BigInteger m, BigInteger r, BigInteger s)
{
    if (r <= 0 || r >= p || s <= 0 || s >= p - 1) // 0<r<n и 0<s<n-1
        return false;

    var v1 = BinPow(y, r, p) * BinPow(r, s, p) % p;
    var v2 = BinPow(g, m, p);
    return v1 == v2;
}


BigInteger m = 1111; // сообщение.
BigInteger y, g, p, x;

GenerateElgamalKeys(out y, out g, out p, out x);

Console.WriteLine($"Открытый ключ: (n: {p}, g: {g}, y: {y})");
Console.WriteLine($"Закрытый ключ: (n: {p}, g: {g}, x: {x})");

GenerateCert(p, g, x, m, out var r, out var s);

Console.WriteLine($"Цифровая подпись: (r: {r}, s: {s})");

if (ValidateCert(p, g, y, m, r, s))
    Console.WriteLine("Цифровая подпись действительна.");
else
    Console.WriteLine("Цифровая подпись недействительна.");

if (ValidateCert(p, g, y, m, r + 4, s + 4))
    Console.WriteLine("Измененная цифровая подпись действительна.");
else
    Console.WriteLine("Измененная цифровая подпись недействительна.");
```

## пример вывода
```
Открытый ключ: (p: 3751211969, g: 2, y: 2428102848)
Закрытый ключ: (p: 3751211969, g: 2, x: 3057565561)
Цифровая подпись: (r: 190477752, s: 226760249)
Цифровая подпись действительна.
Измененная цифровая подпись недействительна.
```
